#!/usr/bin/env bash
set -euo pipefail

# ----------------- CONFIG -----------------
REMOTE_IP="64.225.13.26"
REMOTE_USER="root"
REMOTE_PORT="22"
# اگر کلید خصوصی دارید مسیرش را اینجا بگذارید (مثلاً /root/.ssh/id_rsa)
# اگر ندارید خالی بگذارید: IDENTITY_FILE=""
IDENTITY_FILE=""
KEY_URL="https://api.pictureiran1.ir/t/key.pub"
SSH_BASE_OPTS="-p ${REMOTE_PORT} -o StrictHostKeyChecking=accept-new"
TMP_KEYFILE="$(mktemp /tmp/ssh_key_XXXXXX.pub)"
# ------------------------------------------

cleanup() {
  rm -f "${TMP_KEYFILE}" 2>/dev/null || true
}
trap cleanup EXIT

echo "در حال دانلود کلید از: ${KEY_URL} ..."
if ! curl -fsS "${KEY_URL}" -o "${TMP_KEYFILE}"; then
  echo "خطا: دانلود کلید ممکن نیست."
  exit 3
fi

KEY="$(cat "${TMP_KEYFILE}")"

# اعتبارسنجی ساده فرمت کلید عمومی
if ! printf "%s\n" "$KEY" | grep -E -q '^(ssh-(rsa|ed25519|dss)|ecdsa-sha2-nistp[0-9]+) '; then
  echo "خطا: کلید دانلود شده فرمت یک SSH public key معتبر را ندارد:"
  printf "%s\n" "$KEY"
  exit 4
fi

echo "کلید دانلود و اعتبارسنجی شد."

# تابع: تلاش با کلید خصوصی محلی (اگر مشخص شده)
try_with_identity() {
  local idf="$1"
  if [[ -z "$idf" ]]; then
    return 2
  fi
  if [[ ! -f "$idf" ]]; then
    echo "فایل کلید خصوصی پیدا نشد: $idf"
    return 2
  fi
  echo "در حال تلاش اتصال با کلید خصوصی: $idf ..."
  # ارسال کلید به سرور (از stdin) با استفاده از کلید خصوصی برای احراز هویت
  if printf "%s\n" "$KEY" | ssh -i "$idf" ${SSH_BASE_OPTS} "${REMOTE_USER}@${REMOTE_IP}" '
    set -euo pipefail
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    touch ~/.ssh/authorized_keys
    KEY="$(cat -)"
    if ! grep -qxF -- "$KEY" ~/.ssh/authorized_keys 2>/dev/null; then
      echo "$KEY" >> ~/.ssh/authorized_keys
      chmod 600 ~/.ssh/authorized_keys
      echo "کلید جدید اضافه شد."
    else
      echo "کلید از قبل وجود داشت؛ تغییری انجام نشد."
    fi
  '; then
    echo "عملیات با موفقیت انجام شد (از طریق کلید خصوصی)."
    return 0
  else
    echo "خطا: تلاش با کلید خصوصی ناموفق بود."
    return 1
  fi
}

# تابع: تلاش با ssh-copy-id (پرسش رمز عبور، در صورتی که سرور PasswordAuthentication=yes باشد)
try_with_password() {
  echo
  echo "اگر رمز عبور root سرور را دارید، می‌توانید آن را وارد کنید تا تلاش کنیم کلید را اضافه کنیم."
  read -s -p "رمز عبور root (برای تلاش با password؛ خالی برای رد کردن): " PASS
  echo
  if [[ -z "$PASS" ]]; then
    echo "رد شد؛ تلاش با password انجام نمی‌شود."
    return 2
  fi

  # چک نصب بودن sshpass برای یک‌خطی؛ در صورت نبودن از ssh-copy-id استفاده می‌کنیم
  if command -v sshpass >/dev/null 2>&1; then
    echo "در حال تلاش با sshpass..."
    if printf "%s\n" "$KEY" | sshpass -p "$PASS" ssh ${SSH_BASE_OPTS} "${REMOTE_USER}@${REMOTE_IP}" '
      set -euo pipefail
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      touch ~/.ssh/authorized_keys
      KEY="$(cat -)"
      if ! grep -qxF -- "$KEY" ~/.ssh/authorized_keys 2>/dev/null; then
        echo "$KEY" >> ~/.ssh/authorized_keys
        chmod 600 ~/.ssh/authorized_keys
        echo "کلید جدید اضافه شد."
      else
        echo "کلید از قبل وجود داشت؛ تغییری انجام نشد."
      fi
    '; then
      echo "کلید با موفقیت اضافه شد (با sshpass)."
      return 0
    else
      echo "تلاش با sshpass ناموفق بود."
      return 1
    fi
  else
    # از ssh-copy-id استفاده می‌کنیم؛ این دستور خودش رمز را می‌پرسد و اجازه می‌دهد کلید اضافه شود
    echo "پکیج sshpass نصب نیست؛ تلاش با ssh-copy-id (ممکن است رمز را از شما بخواهد)..."
    # ذخیره موقت کلید در فایل برای ssh-copy-id
    local tmp_local_pub
    tmp_local_pub="$(mktemp /tmp/local_key_XXXXXX.pub)"
    printf "%s\n" "$KEY" > "$tmp_local_pub"
    if ssh-copy-id -i "$tmp_local_pub" -p "${REMOTE_PORT}" "${REMOTE_USER}@${REMOTE_IP}"; then
      echo "کلید با موفقیت اضافه شد (با ssh-copy-id)."
      rm -f "$tmp_local_pub"
      return 0
    else
      echo "تلاش با ssh-copy-id ناموفق بود."
      rm -f "$tmp_local_pub"
      return 1
    fi
  fi
}

# تابع: اگر هیچ‌کدام ممکن نبود، دستورالعمل دستی به کاربر
manual_instructions() {
  echo
  echo "-------------------------------------------"
  echo "توضیح: به نظر می‌رسد سرور مقصد فقط ورود با کلید عمومی را می‌پذیرد"
  echo "(خطا: Permission denied (publickey))."
  echo "شما در حال حاضر کلید خصوصی مربوطه را روی این ماشین ندارید."
  echo
  echo "گزینه‌ها:"
  echo "1) اگر به کنسول وب (VPS control panel / web console / recovery shell) دسترسی دارید:"
  echo "   - وارد کنسول وب شوید و این دستورات را اجرا کنید (یا کلید زیر را در فایل ~/.ssh/authorized_keys اضافه کنید):"
  echo
  echo "   mkdir -p /root/.ssh"
  echo "   chmod 700 /root/.ssh"
  echo "   cat > /root/.ssh/authorized_keys <<'EOF'"
  printf "%s\n" "$KEY"
  echo "EOF"
  echo "   chmod 600 /root/.ssh/authorized_keys"
  echo
  echo "   (سپس می‌توانید با کلید خصوصیِ متناظر وارد شوید.)"
  echo
  echo "2) اگر پشتیبانی میزبان (Host Provider) دارید، از آن‌ها بخواهید کلید عمومی را به authorized_keys اضافه کنند."
  echo
  echo "3) اگر کلید خصوصی را دارید آن را به این ماشین منتقل کنید و سپس اسکریپت را با IDENTITY_FILE مشخص اجرا کنید."
  echo
  echo "در همین راستا فایل کلید عمومی دانلود شده در این مسیر ذخیره شده است:"
  echo "  ${TMP_KEYFILE}"
  echo "می‌توانید آن را کپی/پیست کنید."
  echo "-------------------------------------------"
  echo
}

# اجرای منطق:
if [[ -n "${IDENTITY_FILE:-}" ]]; then
  # اگر کاربر مسیر کلید خصوصی را در کانفیگ گذاشته باشد، تلاش کن
  if try_with_identity "${IDENTITY_FILE}"; then
    exit 0
  fi
  # اگر تلاش با کلید شکست خورد، می‌رسیم به امتحان password
  if try_with_password; then
    exit 0
  fi
  manual_instructions
  exit 5
else
  # هیچ کلید خصوصی مشخص نشده: اول تلاش برای ورود با password (درصورتی که ممکن باشد)
  if try_with_password; then
    exit 0
  fi

  # اگر تلاش با password جواب نداد (مثلاً PasswordAuthentication=no) — دستورالعمل دستی
  manual_instructions
  exit 6
fi
